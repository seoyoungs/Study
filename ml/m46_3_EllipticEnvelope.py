from sklearn.covariance import EllipticEnvelope
import numpy as np

# ------------- 이과정은 모두 전처리전에 잡아야한다 ---------------
aaa = np.array([[1,2,10000,3,4,6,7,8,90,100,5000],
               [100, 200, 3, 400, 500, 600, 700, 8, 900, 1000, 1]]) # 괄호 2개로 해 벡터화
aaa = np.transpose(aaa) 
print(aaa.shape) #(11,2) --> 기준은 열이다

outlier = EllipticEnvelope(contamination=.2) # 20%의 오염비를 찾아라, 디폴트 .1
outlier.fit(aaa)

print(outlier.predict(aaa))
# contamination=.2
# [ 1  1 -1  1  1  1  1  1  1  1 -1] -> 3번째롸 맨 마지막이 아웃라이어
# contamination=.3
# [ 1  1 -1  1  1  1  1  1  1 -1 -1] 내가 임의로 아웃라이어 판단

# --------------- 2차 일때 ---------------------
# 둘중에 하나라도 이상치면 표시 된다
# transpose면
'''
1          100
2          200
-10000      3
3          400
4          500
6          600
7          700
8          8
90         900
100        1000
5000        1
여기서 이상치를 열에서 찾는건데 둘 중에 하나라도 이상치면 이상치라고 표시된다
[ 1  1 -1  1  1  1  1  1  1  1 -1]
'''

'''
aaa = np.array([[1,2,10000,3,4,6,7,8,90,100,5000],
               [100, 200, 3, 400, 500, 600, 700, 8, 900, 1000, 1]]) 
근데 이 데이터를 standardscaler하면 안된다. 이상치가 없다고 나와도 차이가 많이 나므로
데이터의 특성을 잡기가 힘들다
근데 outlier가 아니면 제거하기 힘들다
우리가 오늘 한것을 활용해 percentile로 중위수를 1로 잡는다
그럼 이상치가 제 힘을 발휘하지 못한다 
중위값을 기준으로 하는 것 RobustScaler
장점: standardscaler에 비해 이상치 제거에 효과가 있다
'''